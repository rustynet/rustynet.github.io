Java 3D 

Есть такая известная штука, как JAVA.
Многие считают JAVA чем-то вроде неполноценного языка, неприменимого для создания серьезных проектов.
Говорят, что игры не пишут на яве. Игры сейчас действительно не пишут на яве, но лишь потому, что
аппаратные средства не доросли ещё до неё. Но это можно обойти, просто скомпилировав байт-код явы.
(например при помощи "Excelsior JET"). На самом деле это полнофункциональный язык, единственное, 
что на нем не напишешь - так это "системный" код, вроде драйверов.

Что касается игр, то я приведу несколько игр, которые были написаны с использованием явы. Коммерческие
игры, вопреки бытующему мнению, очень часто используют яву. Во многих случаях она скомпилена или используется
вместе с C или C++.

IL-2 Sturmovik (2001) by Maddox Games. Ява используется для движка и математики игры. Графический движок написан на C++.

На QuakeCon 2001, Fullsail Real World Entertainment представила клон Quake
под названием Jamid. Jamid был полностью написан на java3d.   

Majestic (2001) by Electronic Arts (http://www.ea.com/). Использовалась "грязная" ява вместе с C++.
 
Ява использовалась для скриптования в игре Vampire - the Masquerade:
Redemption (2000) от Nihilistic software (http://www.nihilistic.com/). 

Я нашел инфу на эту тему, но, как видно, она немного просроченная. Моей задачей в данном случае было показать тенденции.

Так что 3д графика на яве - не миф. Есть пакет java3d, который можно найти на сайте SUN microsystems (www.java.sun.com).

Это все общие слова.

К этой статье прилагается немного мной переработанный сырец из официальных демок, в котором, ИМХО, совершенно не сложно
разобраться.

Как и все в яве, 3д сцена и все обьекты на ней представлены в виде классов, и, соответственно, экземпляров этих классов.
Русской документации я, к сожалению, не нашел. Попробую изложить основную суть построения 3д сцены на яве.
Т. к. тут все действительно по-иному.

Я буду описывать все на примере куска кода. Для понимания желательно быть знакомым с С-подобным синтаксисом и
принципами объектно-ориентированного программирования. Ну собственно знание JAVA только приветствуется =).

Начнем.
Я буду описывать только общие принципы. Для выяснения деталей, вроде параметров функций,
обращайтесь к j3d documentation. [http://java.sun.com/products/java-media/3D/index.jsp]

public class TextureImage extends Applet {
  
    private java.net.URL texImage = null;

    public BranchGroup createSceneGraph() {
	// Создается некоторый корневой объект.
	// который и есть основная сцена вообщем-то.
	BranchGroup objRoot = new BranchGroup();

	// Создается объект (группа, как его назвали в экземплах j3dk)
	// который нужен для трансформации объектов. Т.е. для их изменения.
	// В основном  - перемещений, вращений.
	// (TRANSFORM_WRITE для возможности изменения кода runtime)  
	// Дальше, как и любой объект в системе java3d объект трансформа 
	// добавляется в корневую сцену. Дальше к этому обьекту будет 
	// добавляться непосредственно объект со всеми его атрибутами
	// изменений.
	TransformGroup objTrans = new TransformGroup();
	objTrans.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
	objRoot.addChild(objTrans);

	// Appearance - многоцелевой класс для выставления свойств разным объектам.
	// В данном случае мы видим, что этому обьекту задаются 
	// свойства текстурирования.
	Appearance app = new Appearance();
	Texture tex = new TextureLoader(texImage, this).getTexture();
	app.setTexture(tex);
	TextureAttributes texAttr = new TextureAttributes();
	texAttr.setTextureMode(TextureAttributes.MODULATE);
	app.setTextureAttributes(texAttr);

	// Все гениальное просто - создается куб.
	Box textureCube = new Box(0.4f, 0.4f, 0.4f,
				  Box.GENERATE_TEXTURE_COORDS, app);
	objTrans.addChild(textureCube);

	// Создается новый объект, как понятно из названия,
	// для трансформирования определенного объекта.
	// Задается матрица трансформа. В данном случае по Y.
        double[] d = {10.f,10.f,10.f,10.f,
                      0.f,0.f,0.f,0.f,
                      0.f,0.f,0.f,0.f,
                      0.f,0.f,0.f,0.f};

	Transform3D yAxis = new Transform3D();
	Alpha rotationAlpha = new Alpha(-1, Alpha.INCREASING_ENABLE,
					0, 0,
					4000, 0, 0,
					0, 0, 0);
	// Это класс, заставляющий обьект "трансформироваться"
	// самостоятельно. Что-то вроде управляющего класса.
	RotationInterpolator rotator =
	    new RotationInterpolator(rotationAlpha, objTrans, yAxis,
				     0.0f, (float) Math.PI*2.0f);
	// Сфера присутствия объекста.
	BoundingSphere bounds =
	    new BoundingSphere(new Point3d(-100.1f,0.0,0.0), 100.0);
	rotator.setSchedulingBounds(bounds);
	// В TransformGroup добавляются объект и его "свойства".
	// Сам объект objTrans уже принадлежит корневой сцене.
        objTrans.setBounds(new BoundingSphere(new Point3d(-100.0,0.0,0.0),2.0));
	objTrans.addChild(rotator);


        // "Have Java 3D perform optimizations on this scene graph."
	// Оптимизация и подготовка сцены.
        objRoot.compile();

	return objRoot;
    }


Вот в общем-то и вся сцена. Мы увидим текстурированный крутящийся куб.
Исходя из идеологии явы можно представить, насколько можно сделать код модульным и насколько
упростить понимание его сути.

Ява очень гармоничный язык и на нем очень просто писать, если его понимать.
Именно понимать. И 3D графика там соответственно тоже обладает теми же свойствами,
отчего компилятор лучше срастается с твоими мозгами и меньше их ограничивает.
Пусть любители асмы и cpp кинут камень в мой огород, я им дорожку укреплю =).


---
KostaPC [49406]
kostapc@gmail.com
ICQ:178780764

---------------------------------
см. \java3d